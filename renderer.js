/**
 * This is SamJs.js v0.1.1
 *
 * A Javascript port of "SAM Software Automatic Mouth".
 *
 * (c) 2017-2020 Christian Schiffler
 *
 * @link(https://github.com/discordier/sam)
 *
 * @author 2017 Christian Schiffler <c.schiffler@cyberspectrum.de>
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.Renderer = factory());
}(this, (function () { 'use strict';

  var tab48426 = [0x18, 0x1A, 0x17, 0x17, 0x17];

  var stressPitch_tab47492 = [
    0x00, 0x00, 0xE0, 0xE6, 0xEC, 0xF3, 0xF9, 0x00,
    0x06, 0xC, 0x06
  ];

  // Used to decide which phoneme's blend lengths. The candidate with the lower score is selected.
  // tab45856
  var blendRank = [
    0x00, 0x1F, 0x1F, 0x1F, 0x1F, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x05, 0x05,
    0x02, 0x0A, 0x02, 0x08, 0x05, 0x05, 0x0B, 0x0A,
    0x09, 0x08, 0x08, 0xA0, 0x08, 0x08, 0x17, 0x1F,
    0x12, 0x12, 0x12, 0x12, 0x1E, 0x1E, 0x14, 0x14,
    0x14, 0x14, 0x17, 0x17, 0x1A, 0x1A, 0x1D, 0x1D,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x1A, 0x1D,
    0x1B, 0x1A, 0x1D, 0x1B, 0x1A, 0x1D, 0x1B, 0x1A,
    0x1D, 0x1B, 0x17, 0x1D, 0x17, 0x17, 0x1D, 0x17,
    0x17, 0x1D, 0x17, 0x17, 0x1D, 0x17, 0x17, 0x17
  ];

  // Number of frames at the end of a phoneme devoted to interpolating to next phoneme's final value
  //tab45696
  var outBlendLength = [
    0x00, 0x02, 0x02, 0x02, 0x02, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x03, 0x02, 0x04, 0x04, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02,
    0x02, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x04, 0x04, 0x02, 0x00,
    0x01, 0x02, 0x00, 0x01, 0x02, 0x00, 0x01, 0x02,
    0x00, 0x01, 0x02, 0x00, 0x02, 0x02, 0x00, 0x01,
    0x03, 0x00, 0x02, 0x03, 0x00, 0x02, 0xA0, 0xA0
  ];

  // Number of frames at beginning of a phoneme devoted to interpolating to phoneme's final value
  // tab45776
  var inBlendLength = [
    0x00, 0x02, 0x02, 0x02, 0x02, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x03, 0x03, 0x04, 0x04, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x01, 0x02, 0x03, 0x02, 0x01,
    0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03,
    0x03, 0x02, 0x02, 0x03, 0x02, 0x03, 0x00, 0x00,
    0x05, 0x05, 0x05, 0x05, 0x04, 0x04, 0x02, 0x00,
    0x02, 0x02, 0x00, 0x03, 0x02, 0x00, 0x04, 0x02,
    0x00, 0x03, 0x02, 0x00, 0x02, 0x02, 0x00, 0x02,
    0x03, 0x00, 0x03, 0x03, 0x00, 0x03, 0xB0, 0xA0
  ];

  // Looks like it's used as bit flags
  // High bits masked by 248 (11111000)
  //
  // 32: S*    241         11110001
  // 33: SH    226         11100010
  // 34: F*    211         11010011
  // 35: TH    187         10111011
  // 36: /H    124         01111100
  // 37: /X    149         10010101
  // 38: Z*    1           00000001
  // 39: ZH    2           00000010
  // 40: V*    3           00000011
  // 41: DH    3           00000011
  // 43: **    114         01110010
  // 45: **    2           00000010
  // 67: **    27          00011011
  // 70: **    25          00011001
  // tab45936
  var sampledConsonantFlags = [
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF1, 0xE2, 0xD3, 0xBB, 0x7C, 0x95, 0x01, 0x02,
    0x03, 0x03, 0x00, 0x72, 0x00, 0x02, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x19, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  ];

  //
  var frequencyData = [
  //tab45056 |tab451356 |tab45216
  //  freq1  |  freq2   |  freq3
    0x000000 | 0x000000 | 0x000000,
    0x000013 | 0x004300 | 0x5B0000,
    0x000013 | 0x004300 | 0x5B0000,
    0x000013 | 0x004300 | 0x5B0000,
    0x000013 | 0x004300 | 0x5B0000,
    0x00000A | 0x005400 | 0x6E0000,
    0x00000E | 0x004800 | 0x5D0000,
    0x000012 | 0x004200 | 0x5B0000,
    0x000018 | 0x003E00 | 0x580000,
    0x00001A | 0x002800 | 0x590000,
    0x000016 | 0x002C00 | 0x570000,
    0x000014 | 0x001E00 | 0x580000,
    0x000010 | 0x002400 | 0x520000,
    0x000014 | 0x002C00 | 0x590000,
    0x00000E | 0x004800 | 0x5D0000,
    0x000012 | 0x003000 | 0x3E0000,
    0x00000E | 0x002400 | 0x520000,
    0x000012 | 0x001E00 | 0x580000,
    0x000012 | 0x003200 | 0x3E0000,
    0x000010 | 0x002400 | 0x6E0000,
    0x00000C | 0x001C00 | 0x500000,
    0x00000E | 0x004400 | 0x5D0000,
    0x00000A | 0x001800 | 0x5A0000,
    0x000012 | 0x003200 | 0x3C0000,
    0x00000E | 0x001E00 | 0x6E0000,
    0x00000A | 0x001800 | 0x5A0000,
    0x000008 | 0x005200 | 0x6E0000,
    0x000006 | 0x002E00 | 0x510000,
    0x000006 | 0x003600 | 0x790000,
    0x000006 | 0x005600 | 0x650000,
    0x000006 | 0x003600 | 0x790000,
    0x000011 | 0x004300 | 0x5B0000,
    0x000006 | 0x004900 | 0x630000,
    0x000006 | 0x004F00 | 0x6A0000,
    0x000006 | 0x001A00 | 0x510000,
    0x000006 | 0x004200 | 0x790000,
    0x00000E | 0x004900 | 0x5D0000,
    0x000010 | 0x002500 | 0x520000,
    0x000009 | 0x003300 | 0x5D0000,
    0x00000A | 0x004200 | 0x670000,
    0x000008 | 0x002800 | 0x4C0000,
    0x00000A | 0x002F00 | 0x5D0000,
    0x000006 | 0x004F00 | 0x650000,
    0x000006 | 0x004F00 | 0x650000,
    0x000006 | 0x004200 | 0x790000,
    0x000005 | 0x004F00 | 0x650000,
    0x000006 | 0x006E00 | 0x790000,
    0x000000 | 0x000000 | 0x000000,
    0x000012 | 0x004800 | 0x5A0000,
    0x00001A | 0x002600 | 0x580000,
    0x000014 | 0x001E00 | 0x580000,
    0x00001A | 0x002A00 | 0x580000,
    0x000012 | 0x001E00 | 0x580000,
    0x00000C | 0x002200 | 0x520000,
    0x000006 | 0x001A00 | 0x510000,
    0x000006 | 0x001A00 | 0x510000,
    0x000006 | 0x001A00 | 0x510000,
    0x000006 | 0x004200 | 0x790000,
    0x000006 | 0x004200 | 0x790000,
    0x000006 | 0x004200 | 0x790000,
    0x000006 | 0x006E00 | 0x700000,
    0x000006 | 0x006E00 | 0x6E0000,
    0x000006 | 0x006E00 | 0x6E0000,
    0x000006 | 0x005400 | 0x5E0000,
    0x000006 | 0x005400 | 0x5E0000,
    0x000006 | 0x005400 | 0x5E0000,
    0x000006 | 0x001A00 | 0x510000,
    0x000006 | 0x001A00 | 0x510000,
    0x000006 | 0x001A00 | 0x510000,
    0x000006 | 0x004200 | 0x790000,
    0x000006 | 0x004200 | 0x790000,
    0x000006 | 0x004200 | 0x790000,
    0x000006 | 0x006D00 | 0x650000,
    0x00000A | 0x005600 | 0x650000,
    0x00000A | 0x006D00 | 0x700000,
    0x000006 | 0x005400 | 0x5E0000,
    0x000006 | 0x005400 | 0x5E0000,
    0x000006 | 0x005400 | 0x5E0000,
    0x00002C | 0x007F00 | 0x080000,
    0x000013 | 0x007F00 | 0x010000
  ];

  /**
   *
   * ampl1data[X] =  ampldata[X]        & 0xFF; // F1 amplitude
   * ampl2data[X] = (ampldata[X] >> 8)  & 0xFF; // F2 amplitude
   * ampl3data[X] = (ampldata[X] >> 16) & 0xFF; // F3 amplitude
   */
  var ampldata = [
  // ampl1   | ampl2    | ampl3
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x00000D | 0x000A00 | 0x080000,
    0x00000D | 0x000B00 | 0x070000,
    0x00000E | 0x000D00 | 0x080000,
    0x00000F | 0x000E00 | 0x080000,
    0x00000F | 0x000D00 | 0x010000,
    0x00000F | 0x000C00 | 0x010000,
    0x00000F | 0x000C00 | 0x000000,
    0x00000F | 0x000B00 | 0x010000,
    0x00000C | 0x000900 | 0x000000,
    0x00000D | 0x000B00 | 0x070000,
    0x00000C | 0x000B00 | 0x050000,
    0x00000F | 0x000C00 | 0x010000,
    0x00000F | 0x000C00 | 0x000000,
    0x00000D | 0x000C00 | 0x060000,
    0x00000D | 0x000800 | 0x010000,
    0x00000D | 0x000800 | 0x000000,
    0x00000E | 0x000C00 | 0x070000,
    0x00000D | 0x000800 | 0x000000,
    0x00000C | 0x000A00 | 0x050000,
    0x00000D | 0x000800 | 0x010000,
    0x00000D | 0x000800 | 0x000000,
    0x00000D | 0x000A00 | 0x080000,
    0x00000C | 0x000300 | 0x000000,
    0x000009 | 0x000900 | 0x000000,
    0x000009 | 0x000600 | 0x030000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x00000B | 0x000300 | 0x000000,
    0x00000B | 0x000500 | 0x010000,
    0x00000B | 0x000300 | 0x000000,
    0x00000B | 0x000400 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000001 | 0x000000 | 0x000000,
    0x00000B | 0x000500 | 0x010000,
    0x000000 | 0x000A00 | 0x0E0000,
    0x000002 | 0x000200 | 0x010000,
    0x00000E | 0x000E00 | 0x090000,
    0x00000F | 0x000D00 | 0x010000,
    0x00000F | 0x000C00 | 0x000000,
    0x00000F | 0x000D00 | 0x010000,
    0x00000F | 0x000C00 | 0x000000,
    0x00000D | 0x000800 | 0x000000,
    0x000002 | 0x000000 | 0x000000,
    0x000004 | 0x000100 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000002 | 0x000000 | 0x000000,
    0x000004 | 0x000100 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000001 | 0x000000 | 0x000000,
    0x000004 | 0x000100 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000001 | 0x000000 | 0x000000,
    0x000004 | 0x000100 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x00000C | 0x000A00 | 0x070000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000000 | 0x000000,
    0x000000 | 0x000A00 | 0x050000,
    0x000000 | 0x000000 | 0x000000,
    0x00000F | 0x000000 | 0x130000,
    0x00000F | 0x000000 | 0x100000
  ];

  var sinus = Array.apply(null, Array(256)).map(function (n, i) {
    // let y = (Math.sin(2*Math.PI*(i/256)) * 255 | 0);
    //const PI=3.14159265;
    var PI=3.141;
    var y = ((Math.sin(
      (2*PI)*
      ((i)/255)
    )*128 | 0)/16|0)*16;
    return y < 0 ? y+255 : y;
  });

  //random data ?
  var sampleTable = [
    //00
    0x38, 0x84, 0x6B, 0x19, 0xC6, 0x63, 0x18, 0x86,
    0x73, 0x98, 0xC6, 0xB1, 0x1C, 0xCA, 0x31, 0x8C,
    0xC7, 0x31, 0x88, 0xC2, 0x30, 0x98, 0x46, 0x31,
    0x18, 0xC6, 0x35, 0x0C, 0xCA, 0x31, 0xC, 0xC6,
    //20
    0x21, 0x10, 0x24, 0x69, 0x12, 0xC2, 0x31, 0x14,
    0xC4, 0x71, 0x08, 0x4A, 0x22, 0x49, 0xAB, 0x6A,
    0xA8, 0xAC, 0x49, 0x51, 0x32, 0xD5, 0x52, 0x88,
    0x93, 0x6C, 0x94, 0x22, 0x15, 0x54, 0xD2, 0x25,
    //40
    0x96, 0xD4, 0x50, 0xA5, 0x46, 0x21, 0x08, 0x85,
    0x6B, 0x18, 0xC4, 0x63, 0x10, 0xCE, 0x6B, 0x18,
    0x8C, 0x71, 0x19, 0x8C, 0x63, 0x35, 0x0C, 0xC6,
    0x33, 0x99, 0xCC, 0x6C, 0xB5, 0x4E, 0xA2, 0x99,
    //60
    0x46, 0x21, 0x28, 0x82, 0x95, 0x2E, 0xE3, 0x30,
    0x9C, 0xC5, 0x30, 0x9C, 0xA2, 0xB1, 0x9C, 0x67,
    0x31, 0x88, 0x66, 0x59, 0x2C, 0x53, 0x18, 0x84,
    0x67, 0x50, 0xCA, 0xE3, 0x0A, 0xAC, 0xAB, 0x30,
    //80
    0xAC, 0x62, 0x30, 0x8C, 0x63, 0x10, 0x94, 0x62,
    0xB1, 0x8C, 0x82, 0x28, 0x96, 0x33, 0x98, 0xD6,
    0xB5, 0x4C, 0x62, 0x29, 0xA5, 0x4A, 0xB5, 0x9C,
    0xC6, 0x31, 0x14, 0xD6, 0x38, 0x9C, 0x4B, 0xB4,
    //A0
    0x86, 0x65, 0x18, 0xAE, 0x67, 0x1C, 0xA6, 0x63,
    0x19, 0x96, 0x23, 0x19, 0x84, 0x13, 0x08, 0xA6,
    0x52, 0xAC, 0xCA, 0x22, 0x89, 0x6E, 0xAB, 0x19,
    0x8C, 0x62, 0x34, 0xC4, 0x62, 0x19, 0x86, 0x63,
    //C0
    0x18, 0xC4, 0x23, 0x58, 0xD6, 0xA3, 0x50, 0x42,
    0x54, 0x4A, 0xAD, 0x4A, 0x25, 0x11, 0x6B, 0x64,
    0x89, 0x4A, 0x63, 0x39, 0x8A, 0x23, 0x31, 0x2A,
    0xEA, 0xA2, 0xA9, 0x44, 0xC5, 0x12, 0xCD, 0x42,
    //E0
    0x34, 0x8C, 0x62, 0x18, 0x8C, 0x63, 0x11, 0x48,
    0x66, 0x31, 0x9D, 0x44, 0x33, 0x1D, 0x46, 0x31,
    0x9C, 0xC6, 0xB1, 0x0C, 0xCD, 0x32, 0x88, 0xC4,
    0x73, 0x18, 0x86, 0x73, 0x08, 0xD6, 0x63, 0x58,
    //100
    0x07, 0x81, 0xE0, 0xF0, 0x3C, 0x07, 0x87, 0x90,
    0x3C, 0x7C, 0x0F, 0xC7, 0xC0, 0xC0, 0xF0, 0x7C,
    0x1E, 0x07, 0x80, 0x80, 0x00, 0x1C, 0x78, 0x70,
    0xF1, 0xC7, 0x1F, 0xC0, 0x0C, 0xFE, 0x1C, 0x1F,
    //120
    0x1F, 0x0E, 0x0A, 0x7A, 0xC0, 0x71, 0xF2, 0x83,
    0x8F, 0x03, 0x0F, 0x0F, 0x0C, 0x00, 0x79, 0xF8,
    0x61, 0xE0, 0x43, 0x0F, 0x83, 0xE7, 0x18, 0xF9,
    0xC1, 0x13, 0xDA, 0xE9, 0x63, 0x8F, 0x0F, 0x83,
    //140
    0x83, 0x87, 0xC3, 0x1F, 0x3C, 0x70, 0xF0, 0xE1,
    0xE1, 0xE3, 0x87, 0xB8, 0x71, 0x0E, 0x20, 0xE3,
    0x8D, 0x48, 0x78, 0x1C, 0x93, 0x87, 0x30, 0xE1,
    0xC1, 0xC1, 0xE4, 0x78, 0x21, 0x83, 0x83, 0xC3,
    //160
    0x87, 0x06, 0x39, 0xE5, 0xC3, 0x87, 0x07, 0x0E,
    0x1C, 0x1C, 0x70, 0xF4, 0x71, 0x9C, 0x60, 0x36,
    0x32, 0xC3, 0x1E, 0x3C, 0xF3, 0x8F, 0x0E, 0x3C,
    0x70, 0xE3, 0xC7, 0x8F, 0x0F, 0x0F, 0x0E, 0x3C,
    //180
    0x78, 0xF0, 0xE3, 0x87, 0x06, 0xF0, 0xE3, 0x07,
    0xC1, 0x99, 0x87, 0x0F, 0x18, 0x78, 0x70, 0x70,
    0xFC, 0xF3, 0x10, 0xB1, 0x8C, 0x8C, 0x31, 0x7C,
    0x70, 0xE1, 0x86, 0x3C, 0x64, 0x6C, 0xB0, 0xE1,
    //1A0
    0xE3, 0x0F, 0x23, 0x8F, 0x0F, 0x1E, 0x3E, 0x38,
    0x3C, 0x38, 0x7B, 0x8F, 0x07, 0x0E, 0x3C, 0xF4,
    0x17, 0x1E, 0x3C, 0x78, 0xF2, 0x9E, 0x72, 0x49,
    0xE3, 0x25, 0x36, 0x38, 0x58, 0x39, 0xE2, 0xDE,
    //1C0
    0x3C, 0x78, 0x78, 0xE1, 0xC7, 0x61, 0xE1, 0xE1,
    0xB0, 0xF0, 0xF0, 0xC3, 0xC7, 0x0E, 0x38, 0xC0,
    0xF0, 0xCE, 0x73, 0x73, 0x18, 0x34, 0xB0, 0xE1,
    0xC7, 0x8E, 0x1C, 0x3C, 0xF8, 0x38, 0xF0, 0xE1,
    //1E0
    0xC1, 0x8B, 0x86, 0x8F, 0x1C, 0x78, 0x70, 0xF0,
    0x78, 0xAC, 0xB1, 0x8F, 0x39, 0x31, 0xDB, 0x38,
    0x61, 0xC3, 0x0E, 0x0E, 0x38, 0x78, 0x73, 0x17,
    0x1E, 0x39, 0x1E, 0x38, 0x64, 0xE1, 0xF1, 0xC1,
    //200
    0x4E, 0x0F, 0x40, 0xA2, 0x02, 0xC5, 0x8F, 0x81,
    0xA1, 0xFC, 0x12, 0x08, 0x64, 0xE0, 0x3C, 0x22,
    0xE0, 0x45, 0x07, 0x8E, 0x0C, 0x32, 0x90, 0xF0,
    0x1F, 0x20, 0x49, 0xE0, 0xF8, 0x0C, 0x60, 0xF0,
    //220
    0x17, 0x1A, 0x41, 0xAA, 0xA4, 0xD0, 0x8D, 0x12,
    0x82, 0x1E, 0x1E, 0x03, 0xF8, 0x3E, 0x03, 0x0C,
    0x73, 0x80, 0x70, 0x44, 0x26, 0x03, 0x24, 0xE1,
    0x3E, 0x04, 0x4E, 0x04, 0x1C, 0xC1, 0x09, 0xCC,
    //240
    0x9E, 0x90, 0x21, 0x07, 0x90, 0x43, 0x64, 0xC0,
    0x0F, 0xC6, 0x90, 0x9C, 0xC1, 0x5B, 0x03, 0xE2,
    0x1D, 0x81, 0xE0, 0x5E, 0x1D, 0x03, 0x84, 0xB8,
    0x2C, 0x0F, 0x80, 0xB1, 0x83, 0xE0, 0x30, 0x41,
    //260
    0x1E, 0x43, 0x89, 0x83, 0x50, 0xFC, 0x24, 0x2E,
    0x13, 0x83, 0xF1, 0x7C, 0x4C, 0x2C, 0xC9, 0x0D,
    0x83, 0xB0, 0xB5, 0x82, 0xE4, 0xE8, 0x06, 0x9C,
    0x07, 0xA0, 0x99, 0x1D, 0x07, 0x3E, 0x82, 0x8F,
    //280
    0x70, 0x30, 0x74, 0x40, 0xCA, 0x10, 0xE4, 0xE8,
    0x0F, 0x92, 0x14, 0x3F, 0x06, 0xF8, 0x84, 0x88,
    0x43, 0x81, 0x0A, 0x34, 0x39, 0x41, 0xC6, 0xE3,
    0x1C, 0x47, 0x03, 0xB0, 0xB8, 0x13, 0x0A, 0xC2,
    //2A0
    0x64, 0xF8, 0x18, 0xF9, 0x60, 0xB3, 0xC0, 0x65,
    0x20, 0x60, 0xA6, 0x8C, 0xC3, 0x81, 0x20, 0x30,
    0x26, 0x1E, 0x1C, 0x38, 0xD3, 0x01, 0xB0, 0x26,
    0x40, 0xF4, 0x0B, 0xC3, 0x42, 0x1F, 0x85, 0x32,
    //2C0
    0x26, 0x60, 0x40, 0xC9, 0xCB, 0x01, 0xEC, 0x11,
    0x28, 0x40, 0xFA, 0x04, 0x34, 0xE0, 0x70, 0x4C,
    0x8C, 0x1D, 0x07, 0x69, 0x03, 0x16, 0xC8, 0x04,
    0x23, 0xE8, 0xC6, 0x9A, 0x0B, 0x1A, 0x03, 0xE0,
    //2E0
    0x76, 0x06, 0x05, 0xCF, 0x1E, 0xBC, 0x58, 0x31,
    0x71, 0x66, 0x00, 0xF8, 0x3F, 0x04, 0xFC, 0x0C,
    0x74, 0x27, 0x8A, 0x80, 0x71, 0xC2, 0x3A, 0x26,
    0x06, 0xC0, 0x1F, 0x05, 0x0F, 0x98, 0x40, 0xAE,
    //300
    0x01, 0x7F, 0xC0, 0x07, 0xFF, 0x00, 0x0E, 0xFE,
    0x00, 0x03, 0xDF, 0x80, 0x03, 0xEF, 0x80, 0x1B,
    0xF1, 0xC2, 0x00, 0xE7, 0xE0, 0x18, 0xFC, 0xE0,
    0x21, 0xFC, 0x80, 0x3C, 0xFC, 0x40, 0x0E, 0x7E,
    //320
    0x00, 0x3F, 0x3E, 0x00, 0x0F, 0xFE, 0x00, 0x1F,
    0xFF, 0x00, 0x3E, 0xF0, 0x07, 0xFC, 0x00, 0x7E,
    0x10, 0x3F, 0xFF, 0x00, 0x3F, 0x38, 0x0E, 0x7C,
    0x01, 0x87, 0x0C, 0xFC, 0xC7, 0x00, 0x3E, 0x04,
    //340
    0x0F, 0x3E, 0x1F, 0x0F, 0x0F, 0x1F, 0x0F, 0x02,
    0x83, 0x87, 0xCF, 0x03, 0x87, 0x0F, 0x3F, 0xC0,
    0x07, 0x9E, 0x60, 0x3F, 0xC0, 0x03, 0xFE, 0x00,
    0x3F, 0xE0, 0x77, 0xE1, 0xC0, 0xFE, 0xE0, 0xC3,
    //360
    0xE0, 0x01, 0xDF, 0xF8, 0x03, 0x07, 0x00, 0x7E,
    0x70, 0x00, 0x7C, 0x38, 0x18, 0xFE, 0x0C, 0x1E,
    0x78, 0x1C, 0x7C, 0x3E, 0x0E, 0x1F, 0x1E, 0x1E,
    0x3E, 0x00, 0x7F, 0x83, 0x07, 0xDB, 0x87, 0x83,
    //380
    0x07, 0xC7, 0x07, 0x10, 0x71, 0xFF, 0x00, 0x3F,
    0xE2, 0x01, 0xE0, 0xC1, 0xC3, 0xE1, 0x00, 0x7F,
    0xC0, 0x05, 0xF0, 0x20, 0xF8, 0xF0, 0x70, 0xFE,
    0x78, 0x79, 0xF8, 0x02, 0x3F, 0x0C, 0x8F, 0x03,
    //3a0
    0x0F, 0x9F, 0xE0, 0xC1, 0xC7, 0x87, 0x03, 0xC3,
    0xC3, 0xB0, 0xE1, 0xE1, 0xC1, 0xE3, 0xE0, 0x71,
    0xF0, 0x00, 0xFC, 0x70, 0x7C, 0x0C, 0x3E, 0x38,
    0x0E, 0x1C, 0x70, 0xC3, 0xC7, 0x03, 0x81, 0xC1,
    //3c0
    0xC7, 0xE7, 0x00, 0x0F, 0xC7, 0x87, 0x19, 0x09,
    0xEF, 0xC4, 0x33, 0xE0, 0xC1, 0xFC, 0xF8, 0x70,
    0xF0, 0x78, 0xF8, 0xF0, 0x61, 0xC7, 0x00, 0x1F,
    0xF8, 0x01, 0x7C, 0xF8, 0xF0, 0x78, 0x70, 0x3C,
    //3e0
    0x7C, 0xCE, 0x0E, 0x21, 0x83, 0xCF, 0x08, 0x07,
    0x8F, 0x08, 0xC1, 0x87, 0x8F, 0x80, 0xC7, 0xE3,
    0x00, 0x07, 0xF8, 0xE0, 0xEF, 0x00, 0x39, 0xF7,
    0x80, 0x0E, 0xF8, 0xE1, 0xE3, 0xF8, 0x21, 0x9F,
    //400
    0xC0, 0xFF, 0x03, 0xF8, 0x07, 0xC0, 0x1F, 0xF8,
    0xC4, 0x04, 0xFC, 0xC4, 0xC1, 0xBC, 0x87, 0xF0,
    0x0F, 0xC0, 0x7F, 0x05, 0xE0, 0x25, 0xEC, 0xC0,
    0x3E, 0x84, 0x47, 0xF0, 0x8E, 0x03, 0xF8, 0x03,
    //420
    0xFB, 0xC0, 0x19, 0xF8, 0x07, 0x9C, 0x0C, 0x17,
    0xF8, 0x07, 0xE0, 0x1F, 0xA1, 0xFC, 0x0F, 0xFC,
    0x01, 0xF0, 0x3F, 0x00, 0xFE, 0x03, 0xF0, 0x1F,
    0x00, 0xFD, 0x00, 0xFF, 0x88, 0x0D, 0xF9, 0x01,
    //440
    0xFF, 0x00, 0x70, 0x07, 0xC0, 0x3E, 0x42, 0xF3,
    0x0D, 0xC4, 0x7F, 0x80, 0xFC, 0x07, 0xF0, 0x5E,
    0xC0, 0x3F, 0x00, 0x78, 0x3F, 0x81, 0xFF, 0x01,
    0xF8, 0x01, 0xC3, 0xE8, 0x0C, 0xE4, 0x64, 0x8F,
    ////460
    0xE4, 0x0F, 0xF0, 0x07, 0xF0, 0xC2, 0x1F, 0x00,
    0x7F, 0xC0, 0x6F, 0x80, 0x7E, 0x03, 0xF8, 0x07,
    0xF0, 0x3F, 0xC0, 0x78, 0x0F, 0x82, 0x07, 0xFE,
    0x22, 0x77, 0x70, 0x02, 0x76, 0x03, 0xFE, 0x00,
    //480
    0xFE, 0x67, 0x00, 0x7C, 0xC7, 0xF1, 0x8E, 0xC6,
    0x3B, 0xE0, 0x3F, 0x84, 0xF3, 0x19, 0xD8, 0x03,
    0x99, 0xFC, 0x09, 0xB8, 0x0F, 0xF8, 0x00, 0x9D,
    0x24, 0x61, 0xF9, 0x0D, 0x00, 0xFD, 0x03, 0xF0,
    //4a0
    0x1F, 0x90, 0x3F, 0x01, 0xF8, 0x1F, 0xD0, 0xF,
    0xF8, 0x37, 0x01, 0xF8, 0x07, 0xF0, 0x0F, 0xC0,
    0x3F, 0x00, 0xFE, 0x03, 0xF8, 0xF, 0xC0, 0x3F,
    0x00, 0xFA, 0x03, 0xF0, 0xF, 0x80, 0xFF, 0x01,
    //4c0
    0xB8, 0x07, 0xF0, 0x01, 0xFC, 0x01, 0xBC, 0x80,
    0x13, 0x1E, 0x00, 0x7F, 0xE1, 0x40, 0x7F, 0xA0,
    0x7F, 0xB0, 0x00, 0x3F, 0xC0, 0x1F, 0xC0, 0x38,
    0x0F, 0xF0, 0x1F, 0x80, 0xFF, 0x01, 0xFC, 0x03,
    //4e0
    0xF1, 0x7E, 0x01, 0xFE, 0x01, 0xF0, 0xFF, 0x00,
    0x7F, 0xC0, 0x1D, 0x07, 0xF0, 0x0F, 0xC0, 0x7E,
    0x06, 0xE0, 0x07, 0xE0, 0x0F, 0xF8, 0x06, 0xC1,
    0xFE, 0x01, 0xFC, 0x03, 0xE0, 0x0F, 0x00, 0xFC
  ];

  var BREAK = 254;
  var END   = 255;

  // mouth formants (F1) 5..29
  var mouthFormants5_29 = [
    0, 0, 0, 0, 0, 10,
    14, 19, 24, 27, 23, 21, 16, 20, 14, 18, 14, 18, 18,
    16, 13, 15, 11, 18, 14, 11, 9, 6, 6, 6
  ];
  // formant 1 frequencies (mouth) 48..53
  var mouthFormants48_53 = [19, 27, 21, 27, 18, 13];

  // throat formants (F2) 5..29
  var throatFormants5_29 = [
    255, 255,
    255, 255, 255, 84, 73, 67, 63, 40, 44, 31, 37, 45, 73, 49,
    36, 30, 51, 37, 29, 69, 24, 50, 30, 24, 83, 46, 54, 86 ];
  // formant 2 frequencies (throat) 48..53
  var throatFormants48_53 = [72, 39, 31, 43, 30, 34];

  function trans(mem39212, mem39213) {
    return ((((mem39212 & 0xFF) * (mem39213 & 0xFF)) >> 8) & 0xFF) << 1;
  }

  /**
   * SAM's voice can be altered by changing the frequencies of the
   * mouth formant (F1) and the throat formant (F2). Only the voiced
   * phonemes (5-29 and 48-53) are altered.
   *
   * This returns the three base frequency arrays.
   *
   * @return {Array}
   */
  function SetMouthThroat(mouth, throat) {
    var initialFrequency;
    var newFrequency = 0;
    var pos = 5;

    var freqdata = [[],[],[]];
    frequencyData.map(function (v, i) {
      freqdata[0][i] = v & 0xFF;
      freqdata[1][i] = (v >> 8) & 0xFF;
      freqdata[2][i] = (v >> 16) & 0xFF;
    });

    // recalculate formant frequencies 5..29 for the mouth (F1) and throat (F2)
    while(pos < 30) {
      // recalculate mouth frequency
      initialFrequency = mouthFormants5_29[pos];
      if (initialFrequency !== 0) {
        newFrequency = trans(mouth, initialFrequency);
      }
      freqdata[0][pos] = newFrequency;

      // recalculate throat frequency
      initialFrequency = throatFormants5_29[pos];
      if(initialFrequency !== 0) {
        newFrequency = trans(throat, initialFrequency);
      }
      freqdata[1][pos] = newFrequency;
      pos++;
    }

    // recalculate formant frequencies 48..53
    pos = 0;
    while(pos < 6) {
      // recalculate F1 (mouth formant)
      initialFrequency = mouthFormants48_53[pos];
      newFrequency = trans(mouth, initialFrequency);
      freqdata[0][pos+48] = newFrequency;
      // recalculate F2 (throat formant)
      initialFrequency = throatFormants48_53[pos];
      newFrequency = trans(throat, initialFrequency);
      freqdata[1][pos+48] = newFrequency;
      pos++;
    }

    return freqdata;
  }

  /**
   * CREATE TRANSITIONS.
   *
   * Linear transitions are now created to smoothly connect each
   * phoeneme. This transition is spread between the ending frames
   * of the old phoneme (outBlendLength), and the beginning frames
   * of the new phoneme (inBlendLength).
   *
   * To determine how many frames to use, the two phonemes are
   * compared using the blendRank[] table. The phoneme with the
   * smaller score is used. In case of a tie, a blend of each is used:
   *
   *      if blendRank[phoneme1] ==  blendRank[phomneme2]
   *          // use lengths from each phoneme
   *          outBlendFrames = outBlend[phoneme1]
   *          inBlendFrames = outBlend[phoneme2]
   *      else if blendRank[phoneme1] < blendRank[phoneme2]
   *          // use lengths from first phoneme
   *          outBlendFrames = outBlendLength[phoneme1]
   *          inBlendFrames = inBlendLength[phoneme1]
   *      else
   *          // use lengths from the second phoneme
   *          // note that in and out are swapped around!
   *          outBlendFrames = inBlendLength[phoneme2]
   *          inBlendFrames = outBlendLength[phoneme2]
   *
   *  Blend lengths can't be less than zero.
   *
   * For most of the parameters, SAM interpolates over the range of the last
   * outBlendFrames-1 and the first inBlendFrames.
   *
   * The exception to this is the Pitch[] parameter, which is interpolates the
   * pitch from the center of the current phoneme to the center of the next
   * phoneme.
   *
   * @param {Uint8Array} pitches
   * @param {Uint8Array} frequency
   * @param {Uint8Array} amplitude
   * @param {Array} tuples
   *
   * @return {Number}
   */
  function CreateTransitions(pitches, frequency, amplitude, tuples) {
    // 0=pitches
    // 1=frequency1
    // 2=frequency[1]
    // 3=frequency3
    // 4=amplitude1
    // 5=amplitude2
    // 6=amplitude3
    var tables = [pitches, frequency[0], frequency[1], frequency[2], amplitude[0], amplitude[1], amplitude[2]];
    var Read = function (table, pos) {
      {
        if (table < 0 || table > tables.length -1 ) {
          throw new Error(("Error invalid table in Read: " + table));
        }
      }
      return tables[table][pos];
    };

    // linearly interpolate values
    var interpolate = function (width, table, frame, mem53) {
      var sign      = (mem53 < 0);
      var remainder = Math.abs(mem53) % width;
      var div       = (mem53 / width) | 0;

      var error = 0;
      var pos   = width;

      while (--pos > 0) {
        var val = Read(table, frame) + div;
        error += remainder;
        if (error >= width) {
          // accumulated a whole integer error, so adjust output
          error -= width;
          if (sign) {
            val--;
          } else if (val) {
            // if input is 0, we always leave it alone
            val++;
          }
        }

        // Write updated value back to next frame.
        {
          if (table < 0 || table > tables.length -1 ) {
            throw new Error(("Error invalid table in Read: " + table));
          }
        }
        tables[table][++frame] = val;
        val += div;
      }
    };

    var phase1;
    var phase2;
    var mem49 = 0;
    for (var pos=0;pos<tuples.length - 1;pos++) {
      var phoneme      = tuples[pos][0];
      var next_phoneme = tuples[pos+1][0];

      // get the ranking of each phoneme
      var next_rank = blendRank[next_phoneme];
      var rank      = blendRank[phoneme];

      // compare the rank - lower rank value is stronger
      if (rank === next_rank) {
        // same rank, so use out blend lengths from each phoneme
        phase1 = outBlendLength[phoneme];
        phase2 = outBlendLength[next_phoneme];
      } else if (rank < next_rank) {
        // next phoneme is stronger, so us its blend lengths
        phase1 = inBlendLength[next_phoneme];
        phase2 = outBlendLength[next_phoneme];
      } else {
        // current phoneme is stronger, so use its blend lengths
        // note the out/in are swapped
        phase1 = outBlendLength[phoneme];
        phase2 = inBlendLength[phoneme];
      }
      mem49 += tuples[pos][1];
      var speedcounter = mem49 + phase2;
      var phase3       = mem49 - phase1;
      var transition   = phase1 + phase2; // total transition?

      if (((transition - 2) & 128) === 0) {
        // unlike the other values, the pitches[] interpolates from
        // the middle of the current phoneme to the middle of the
        // next phoneme

        // half the width of the current and next phoneme
        var cur_width  = tuples[pos][1] >> 1;
        var next_width = tuples[pos+1][1] >> 1;
        var pitch = pitches[next_width + mem49] - pitches[mem49 - cur_width];
        // sum the values
        interpolate(cur_width + next_width, 0, phase3, pitch);

        for (var table = 1; table < 7;table++) {
          // tables:
          // 0  pitches[]
          // 1  frequency1
          // 2  frequency[1]
          // 3  frequency3
          // 4  amplitude1
          // 5  amplitude2
          // 6  amplitude3
          var value = Read(table, speedcounter) - Read(table, phase3);
          interpolate(transition, table, phase3, value);
        }
      }
    }

    // add the length of this phoneme
    return (mem49 + tuples[tuples.length - 1][1]) & 0xFF;
  }

  var PHONEME_PERIOD = 1;
  var PHONEME_QUESTION = 2;

  var RISING_INFLECTION = 1;
  var FALLING_INFLECTION = 255;

  /**
   * Create a rising or falling inflection 30 frames prior to index X.
   * A rising inflection is used for questions, and a falling inflection is used for statements.
   */
  function AddInflection (inflection, pos, pitches) {
    // store the location of the punctuation
    var end = pos;
    if (pos < 30) {
      pos = 0;
    } else {
      pos -= 30;
    }

    var A;
    // FIXME: Explain this fix better, it's not obvious
    // ML : A =, fixes a problem with invalid pitch with '.'
    while ((A = pitches[pos]) === 127) {
      ++pos;
    }

    while (pos !== end) {
      // add the inflection direction
      A += inflection;

      // set the inflection
      pitches[pos] = A & 0xFF;

      while ((++pos !== end) && pitches[pos] === 255) { /* keep looping */}
    }
  }

  /** CREATE FRAMES
   *
   * The length parameter in the list corresponds to the number of frames
   * to expand the phoneme to. Each frame represents 10 milliseconds of time.
   * So a phoneme with a length of 7 = 7 frames = 70 milliseconds duration.
   *
   * The parameters are copied from the phoneme to the frame verbatim.
   *
   * Returns:
   *   [
   *      pitches,
   *      frequency,
   *      amplitude,
   *      sampledConsonantFlag
   *   ]
   *
   * @param {Number}       pitch          Input
   * @param {Array}        tuples         Input
   * @param {Uint8Array[]} frequencyData  Input
   *
   * @return Array
   */
  function CreateFrames (
    pitch,
    tuples,
    frequencyData) {
    var pitches              = [];
    var frequency            = [[], [], []];
    var amplitude            = [[], [], []];
    var sampledConsonantFlag = [];

    var X = 0;
    for (var i=0;i<tuples.length;i++) {
      // get the phoneme at the index
      var phoneme = tuples[i][0];
      if (phoneme === PHONEME_PERIOD) {
        AddInflection(RISING_INFLECTION, X, pitches);
      } else if (phoneme === PHONEME_QUESTION) {
        AddInflection(FALLING_INFLECTION, X, pitches);
      }

      // get the stress amount (more stress = higher pitch)
      var phase1 = stressPitch_tab47492[tuples[i][2] + 1];
      // get number of frames to write
      // copy from the source to the frames list
      for (var frames = tuples[i][1];frames > 0;frames--) {
        frequency[0][X]         = frequencyData[0][phoneme];      // F1 frequency
        frequency[1][X]         = frequencyData[1][phoneme];      // F2 frequency
        frequency[2][X]         = frequencyData[2][phoneme];      // F3 frequency
        amplitude[0][X]         = ampldata[phoneme] & 0xFF;         // F1 amplitude
        amplitude[1][X]         = (ampldata[phoneme] >> 8) & 0xFF;  // F2 amplitude
        amplitude[2][X]         = (ampldata[phoneme] >> 16) & 0xFF; // F3 amplitude
        sampledConsonantFlag[X] = sampledConsonantFlags[phoneme]; // phoneme data for sampled consonants
        pitches[X]              = (pitch + phase1) & 0xFF;        // pitch
        X++;
      }
    }

    return [
      pitches,
      frequency,
      amplitude,
      sampledConsonantFlag
    ];
  }

  function CreateOutputBuffer(buffersize) {
    var buffer = new Uint8Array(buffersize);
    var bufferpos = 0;
    var oldTimeTableIndex = 0;
    // Writer to buffer.
    var writer = function (index, A) {
      writer.raw(index, (A & 15) * 16);
    };
    writer.raw = function (index, A) {
      writer.ary(index, [A, A, A, A, A]);
    };
    writer.ary = function (index, array) {
      // timetable for more accurate c64 simulation
      var timetable = [
        [162, 167, 167, 127, 128],
        [226, 60, 60, 0, 0],
        [225, 60, 59, 0, 0],
        [200, 0, 0, 54, 55],
        [199, 0, 0, 54, 54]
      ];
      bufferpos += timetable[oldTimeTableIndex][index];
      if (((bufferpos / 50) | 0) > buffer.length) {
        {
          throw new Error(("Buffer overflow, want " + (((bufferpos / 50) | 0)) + " but buffersize is only " + (buffer.length) + "!"));
        }
      }
      oldTimeTableIndex = index;
      // write a little bit in advance
      for (var k = 0; k < 5; k++) {
        buffer[(bufferpos / 50 | 0) + k] = array[k];
      }
    };
    writer.get = function () {
      return buffer.slice(0, bufferpos / 50 | 0);
    };
    return writer;
  }

  /**
   * @param {Array} phonemes
   * @param {Number} [pitch]
   * @param {Number} [mouth]
   * @param {Number} [throat]
   * @param {Number} [speed]
   * @param {Boolean} [singmode]
   *
   * @return Uint8Array
   */
  function Renderer(phonemes, pitch, mouth, throat, speed, singmode) {
    pitch = (pitch === undefined) ? 64 : pitch & 0xFF;
    mouth = (mouth === undefined) ? 128 : mouth & 0xFF;
    throat = (throat === undefined) ? 128 : throat & 0xFF;
    speed = (speed || 72) & 0xFF;
    singmode = singmode || false;

    // Every frame is 20ms long.
    var Output = CreateOutputBuffer(
      441 // = (22050/50)
      * phonemes.reduce(function (pre, v) { return pre + (v[1] * 20); }, 0) / 50 // Combined phoneme length in ms.
      * speed | 0 // multiplied by speed.
    );

    var freqdata = SetMouthThroat(mouth, throat);

    // Main render loop.
    var srcpos  = 0; // Position in source
    // FIXME: should be tuple buffer as well.
    var tuples = [];
    while(1) {
      var A = phonemes[srcpos];
      if (A[0]) {
        if (A[0] === END) {
          Render(tuples);
          return Output.get();
        }
        if (A[0] === BREAK) {
          Render(tuples);
          tuples = [];
        } else {
          tuples.push(A);
        }
      }
      ++srcpos;
    }

    /**
     * RENDER THE PHONEMES IN THE LIST
     *
     * The phoneme list is converted into sound through the steps:
     *
     * 1. Copy each phoneme <length> number of times into the frames list,
     *    where each frame represents 10 milliseconds of sound.
     *
     * 2. Determine the transitions lengths between phonemes, and linearly
     *    interpolate the values across the frames.
     *
     * 3. Offset the pitches by the fundamental frequency.
     *
     * 4. Render the each frame.
     *
     * @param {Array} tuples
     */
    function Render (tuples) {
      if (tuples.length === 0) {
        return; //exit if no data
      }

      var ref = CreateFrames(
        pitch,
        tuples,
        freqdata
      );
      var pitches = ref[0];
      var frequency = ref[1];
      var amplitude = ref[2];
      var sampledConsonantFlag = ref[3];

      var t = CreateTransitions(
        pitches,
        frequency,
        amplitude,
        tuples
      );

      if (!singmode) {
        /* ASSIGN PITCH CONTOUR
         *
         * This subtracts the F1 frequency from the pitch to create a
         * pitch contour. Without this, the output would be at a single
         * pitch level (monotone).
         */
        for(var i = 0; i < pitches.length; i++) {
          // subtract half the frequency of the formant 1.
          // this adds variety to the voice
          pitches[i] -= (frequency[0][i] >> 1);
        }
      }

      /*
       * RESCALE AMPLITUDE
       *
       * Rescale volume from a linear scale to decibels.
       */
      var amplitudeRescale = [
        0x00, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04,
        0x04, 0x05, 0x06, 0x08, 0x09, 0x0B, 0x0D, 0x0F,
        0x00  //17 elements?
      ];
      for(var i$1 = amplitude[0].length - 1; i$1 >= 0; i$1--) {
        amplitude[0][i$1] = amplitudeRescale[amplitude[0][i$1]];
        amplitude[1][i$1] = amplitudeRescale[amplitude[1][i$1]];
        amplitude[2][i$1] = amplitudeRescale[amplitude[2][i$1]];
      }

      {
        PrintOutput(pitches, frequency, amplitude, sampledConsonantFlag);
      }

      ProcessFrames(t, speed, frequency, pitches, amplitude, sampledConsonantFlag);
    }

    /**
     * PROCESS THE FRAMES
     *
     * In traditional vocal synthesis, the glottal pulse drives filters, which
     * are attenuated to the frequencies of the formants.
     *
     * SAM generates these formants directly with sin and rectangular waves.
     * To simulate them being driven by the glottal pulse, the waveforms are
     * reset at the beginning of each glottal pulse.
     */
    function ProcessFrames(frameCount, speed, frequency, pitches, amplitude, sampledConsonantFlag) {
      var RenderSample = function (mem66, consonantFlag, mem49) {
        // mem49 == current phoneme's index - unsigned char

        // mask low three bits and subtract 1 get value to
        // convert 0 bits on unvoiced samples.
        var hibyte = (consonantFlag & 7) - 1;

        // determine which offset to use from table { 0x18, 0x1A, 0x17, 0x17, 0x17 }
        // T, S, Z                0          0x18
        // CH, J, SH, ZH          1          0x1A
        // P, F*, V, TH, DH       2          0x17
        // /H                     3          0x17
        // /X                     4          0x17

        var hi = hibyte * 256 & 0xFFFF; // unsigned short
        var off;
        // voiced sample?
        var pitch = consonantFlag & 248; // unsigned char

        function renderSample (index1, value1, index2, value2) {
          var bit = 8;
          var sample = sampleTable[hi+off];
          do {
            if ((sample & 128) !== 0) {
              Output(index1, value1);
            } else {
              Output(index2, value2);
            }
            sample <<= 1;
          } while(--bit);
        }

        if(pitch === 0) {
          // voiced phoneme: Z*, ZH, V*, DH
          var phase1 = (pitches[mem49 & 0xFF] >> 4) ^ 255 & 0xFF; // unsigned char
          off = mem66 & 0xFF; // unsigned char
          do {
            renderSample(3, 26, 4, 6);
            off++;
          } while (++phase1 & 0xFF);
          return off;
        }
        // unvoiced
        off = pitch ^ 255 & 0xFF; // unsigned char
        var mem53 = tab48426[hibyte] & 0xFF; // unsigned char
        do {
          renderSample(2, 5, 1, mem53);
        } while (++off & 0xFF);

        return mem66;
      };

      var speedcounter = 72;
      var phase1 = 0;
      var phase2 = 0;
      var phase3 = 0;
      var mem66 = 0;
      var pos = 0;
      var glottal_pulse = pitches[0];
      var mem38 = glottal_pulse * .75 |0;

      while(frameCount) {
        var flags = sampledConsonantFlag[pos];

        // unvoiced sampled phoneme?
        if ((flags & 248) !== 0) {
          mem66 = RenderSample(mem66, flags, pos);
          // skip ahead two in the phoneme buffer
          pos += 2;
          frameCount -= 2;
          speedcounter = speed;
        } else {
          {
            // Rectangle table consisting of:
            //   0-128 = 0x90
            // 128-255 = 0x70

            // Remove multtable, replace with logical equivalent.
            // Multtable stored the result of a 8-bit signed multiply of the upper nibble of sin/rect (interpreted as signed)
            // and the amplitude lower nibble (interpreted as unsigned), then divided by two.
            // On the 6510 this made sense, but in modern processors it's way faster and cleaner to simply do the multiply.
            var char = function (x) { return (x & 0x7F) - (x & 0x80); };
            // simulate the glottal pulse and formants
            var ary = [];
            var /* unsigned int */ p1 = phase1 * 256; // Fixed point integers because we need to divide later on
            var /* unsigned int */ p2 = phase2 * 256;
            var /* unsigned int */ p3 = phase3 * 256;
            var k = (void 0);
            for (k=0; k<5; k++) {
              var /* signed char */ sp1 = char(sinus[0xff & (p1>>8)]);
              var /* signed char */ sp2 = char(sinus[0xff & (p2>>8)]);
              var /* signed char */ rp3 = char(0xff & (((p3>>8)<129) ? 0x90 : 0x70));
              var /* signed int */ sin1 = sp1 * (/* (unsigned char) */ amplitude[0][pos] & 0x0F);
              var /* signed int */ sin2 = sp2 * (/* (unsigned char) */ amplitude[1][pos] & 0x0F);
              var /* signed int */ rect = rp3 * (/* (unsigned char) */ amplitude[2][pos] & 0x0F);
              var /* signed int */ mux = sin1 + sin2 + rect;
              mux /= 32;
              mux += 128; // Go from signed to unsigned amplitude
              ary[k] = mux |0;
              p1 += frequency[0][pos] * 256 / 4; // Compromise, this becomes a shift and works well
              p2 += frequency[1][pos] * 256 / 4;
              p3 += frequency[2][pos] * 256 / 4;
            }
            Output.ary(0, ary);
          }

          speedcounter--;
          if (speedcounter === 0) {
            pos++; //go to next amplitude
            // decrement the frame count
            frameCount--;
            if(frameCount === 0) {
              return;
            }
            speedcounter = speed;
          }

          glottal_pulse--;

          if(glottal_pulse !== 0) {
            // not finished with a glottal pulse

            mem38--;
            // within the first 75% of the glottal pulse?
            // is the count non-zero and the sampled flag is zero?
            if((mem38 !== 0) || (flags === 0)) {
              // reset the phase of the formants to match the pulse
              // TODO: we should have a switch to disable this, it causes a pretty nice voice without the masking!
              phase1 = phase1 + frequency[0][pos] & 0xFF;
              phase2 = phase2 + frequency[1][pos] & 0xFF;
              phase3 = phase3 + frequency[2][pos] & 0xFF;
              continue;
            }

            // voiced sampled phonemes interleave the sample with the
            // glottal pulse. The sample flag is non-zero, so render
            // the sample for the phoneme.
            mem66 = RenderSample(mem66, flags, pos);
          }
        }

        glottal_pulse = pitches[pos];
        mem38 = glottal_pulse * .75 |0;

        // reset the formant wave generators to keep them in
        // sync with the glottal pulse
        phase1 = 0;
        phase2 = 0;
        phase3 = 0;
      }
    }
  }

  function PrintOutput(pitches, frequency, amplitude, sampledConsonantFlag) {
    function pad(num) {
      var s = '00000' + num;
      return s.substr(s.length - 5);
    }
    console.log('===========================================');
    console.log('Final data for speech output:');
    console.log(' flags ampl1 freq1 ampl2 freq2 ampl3 freq3 pitch');
    console.log('------------------------------------------------');
    for (var i=0;i<sampledConsonantFlag.length;i++) {
      console.log(
        ' %s %s %s %s %s %s %s %s',
        pad(sampledConsonantFlag[i]),
        pad(amplitude[0][i]),
        pad(frequency[0][i]),
        pad(amplitude[1][i]),
        pad(frequency[1][i]),
        pad(amplitude[2][i]),
        pad(frequency[2][i]),
        pad(pitches[i])
      );
      i++;
    }
    console.log('===========================================');
  }

  return Renderer;

})));

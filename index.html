<!-- canvas editor taken from http://www.williammalone.com/articles/create-html5-canvas-javascript-drawing-app/ -->
<!-- sound transformations from http://arss.sourceforge.net/code.shtml -->
<!-- JS port of FFTW from https://github.com/j-funk/js-dsp-test/tree/master/fft/fftw -->
<!-- JS port of SAM from https://github.com/discordier/sam -->
<style>
  li, label, input { display: inline-block; }
  #playground { width: 400px; margin-top: 1em; }
  label { width: 30% }
  #playground input { width: 60%; }
  button#say { width: 100%; }
  input[type="range"] { transform: rotate(180deg); }
  #canvas { cursor: default; }
</style>
<ul style="list-style-type:none;padding-left:0">
	<li><button id="clearCanvas" type="button">Clear</button></li>
        <li id="chooseColor"><button type="button" style="background-color:black">&nbsp;</button><button type="button" style="background-color:dimgray">&nbsp;</button><button type="button" style="background-color:lightgray">&nbsp;</button><button type="button" style="background-color:white">&nbsp;</button></li>
        <li id="chooseSize"><button type="button" style="border-width:1px">&nbsp;</button><button type="button" style="border-width:2.5px">&nbsp;</button><button type="button" style="border-width:5px">&nbsp;</button><button type="button" style="border-width:10px">&nbsp;</button></li>
	<li><button id="play" type="button">Play</button></li>
	<li><input id="loop" type="checkbox" checked>Loop</button></li>
	<li><button id="copy" type="button">Copy</button></li>
</ul>
<div class="image">
	<canvas id="canvas" />
</div>
<div id="playground">
  <div>
    <label for="speechinput">Text to speak:</label>
    <input size="60" id="speechinput" value="/HOH5TEHL, AH5LFAH, BRAH4VOW, ROW5MIHOW">
  <hr>
    <label id="pitch-lbl" for="pitch">Pitch:   </label><input type="range" id="pitch" min="0" max="255" value="0" />
    <label id="speed-lbl" for="speed">Speed:   </label><input type="range" id="speed" min="1" max="255" value="0" />
    <label id="mouth-lbl" for="mouth">Mouth:   </label><input type="range" id="mouth" min="0" max="255" value="0" />
    <label id="throat-lbl" for="throat">Throat: </label><input type="range" id="throat" min="0" max="255" value="0" />
    <button type="button" id="say">Say</button>
  </div>
</div>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.js"></script>
<script src="FFTW.js"></script>
<script src="parser.js"></script>
<script src="renderer.js"></script>
<script>
var canvasWidth = 400;
var canvasHeight = 225;

var clickX;
var clickY;
var paint;
var canvasContext;

function prepareCanvas()
{
	var canvas = document.getElementById('canvas');
	canvas.width = canvasWidth;
	canvas.height = canvasHeight;
	canvasContext = canvas.getContext("2d"); // Grab the 2d canvas context

	var initialImage = new Image();
	initialImage.src = location.hash ? location.hash.substring(1) : "habr.png";
	initialImage.onload = function() {
		canvasContext.drawImage(initialImage, 0, 0, canvasWidth, canvasHeight);
	}
	canvasContext.lineWidth = 5;
	canvasContext.strokeStyle = "white";
	canvasContext.lineJoin = "round";

	var undoBuffer;
	
	// Add mouse events
	// ----------------
	$('#canvas').mousedown(function(e) {
		undoBuffer = canvasContext.getImageData(0, 0, canvasWidth, canvasHeight);

		// Mouse down location
		clickX = e.pageX - this.offsetLeft;
		clickY = e.pageY - this.offsetTop;
		
		paint = true;
		canvasContext.beginPath();
		canvasContext.moveTo(clickX - 1, clickY);
		canvasContext.lineTo(clickX, clickY);
		canvasContext.closePath();
		canvasContext.stroke();
	});
	
	$('#canvas').mousemove(function(e) {
		if (paint) {
			canvasContext.beginPath();
			canvasContext.moveTo(clickX, clickY);
			clickX = e.pageX - this.offsetLeft;
			clickY = e.pageY - this.offsetTop;
			canvasContext.lineTo(clickX, clickY);
			canvasContext.closePath();
			canvasContext.stroke();
		}
	});
	
	$('#canvas').mouseup(function(e) {
		paint = false;
	});
	
	$('#canvas').mouseleave(function(e) {
		paint = false;
	});
	
	$('#chooseColor button').mousedown(function(e) {
		canvasContext.strokeStyle = e.target.style.backgroundColor;
	});
	$('#chooseSize button').mousedown(function(e) {
		canvasContext.lineWidth = e.target.style.borderWidth.match(/\d+/) * 2;
	});
	$('#clearCanvas').mousedown(clear);
	function clear() {
		canvasContext.fillRect(0, 0, canvasWidth, canvasHeight);
	}
	$('#copy').mousedown(function(e) {
		var imageData = canvasContext.getImageData(0, 0, canvasWidth, canvasHeight);
		for (var y=0; y<canvasHeight; y++)
			for (var x=0; x<canvasWidth; x++)
				imageData.data[4*(canvasWidth*y+x)+1] =imageData.data[4*(canvasWidth*y+x)+2] =0;
		canvasContext.putImageData(imageData, 0, 0);
	});
	$('#play').mousedown(play);

	$(document).keydown(function(e) {
		if (e.keyCode == 90 && e.ctrlKey && undoBuffer)
			canvasContext.putImageData(undoBuffer, 0, 0);
	});

	if (!window.AudioContext) {
		if (!window.webkitAudioContext) {
			alert("Your browser does not support any AudioContext and cannot play back audio.");
			return;
		}
		window.AudioContext = window.webkitAudioContext;
	}

	var context;

	function play() {
		if (!context)
			context = new AudioContext();

		$('#play').prop("disabled", true);
		var imageData = canvasContext.getImageData(0, 0, canvasWidth, canvasHeight).data;
		var pixels = [];
		for (var y=0; y<canvasHeight; y++)
		{
			pixels[y] = [];
			for (var x=0; x<canvasWidth; x++)
				pixels[y][x] = (//imageData[4*(canvasWidth*y+x)] +
						imageData[4*(canvasWidth*y+x)+1] +
						imageData[4*(canvasWidth*y+x)+2]) / (255.0 * 2.0); // Conversion to grey by averaging the three channels
		}
		var audioBuffer = synt_sine(pixels);

		// Create a source node from the buffer
		var source = context.createBufferSource();
		// Fill in source.buffer from audioBuffer
		var soundBuffer = context.createBuffer(1, audioBuffer.length, samplerate);
		var buffer = soundBuffer.getChannelData(0);
		for(var i=0; i<audioBuffer.length; i++)
			buffer[i] = audioBuffer[i];
		source.buffer = soundBuffer;
		// Connect to the final output node (the speakers)
		source.connect(context.destination);
		// Play immediately
		source.start(0);
		source.onended = function(){ if ($('#loop').prop("checked")) play(); else $('#play').prop("disabled", false); };
	}

	function say() {
		function pset(x, freq, v) {
			var y = log_pos_inv(freq*.57/1024, basefreq, maxfreq) * (canvasHeight-1);
			canvasContext.fillStyle = 'rgba(' + [v,v,v,1].toString() + ')';
			canvasContext.fillRect(x, canvasHeight - y, 1, 1);
		}
		clear();
		var x = 0;

		var parsed = Parser(document.getElementById('speechinput').value);
		var sentences = Renderer(parsed, opts.pitch, opts.mouth, opts.throat, /*singmode*/false);
		for (var sentence of sentences) {
			var [frameCount, frequency, pitches, amplitude, sampledConsonantFlag] = sentence;

			for (var pos=0; pos<frameCount; x++, pos++) {
				let flags = sampledConsonantFlag[pos];

				// unvoiced sampled phoneme?
				if ((flags & 248) !== 0) {
					//TODO: RenderSample(flags, pitches[pos & 0xFF]);
					// skip ahead two in the phoneme buffer
					pos++;
					continue;
				} else {
					pset(x, frequency[0][pos], amplitude[0][pos] * 17);
					pset(x, frequency[1][pos], amplitude[1][pos] * 17);
					pset(x, frequency[2][pos], amplitude[2][pos] * 17);

					if (flags !== 0) {
						// voiced sampled phonemes interleave the sample with the
						// glottal pulse.
						//TODO: RenderSample(flags, pitches[pos & 0xFF]);
					}
				}
			}
		}
	}
	$('#say').mousedown(say);

	var opts = {
		debug: 1,
		pitch: 64,
		speed: 170,
		mouth: 128,
		throat: 128
	};
	for (var name of ['speed', 'pitch', 'mouth', 'throat']) {
		var e = document.getElementById(name);
		e.onchange = function (e) {
			opts[e.target.id] = e.target.value;
			document.getElementById(e.target.id + '-lbl').innerText =
				e.target.id.charAt(0).toUpperCase() + e.target.id.substr(1) + ': ' + e.target.value;
			say();
		};
		e.value = opts[name];
	}
}

function log_pos(x, min, max) // turns a logarithmic position (i.e. band number/band count) to a frequency
{
	return min * Math.pow(2.0, x * (Math.log2(max) - Math.log2(min)));
}

function log_pos_inv(x, min, max)  // turns a frequency to a logarithmic position (i.e. band number/band count)
{
        return Math.log2(x / min) / (Math.log2(max) - Math.log2(min));
}

function smallprimes(x)   // returns 1 if x is only made of these small primes
{
        var i, p=[2, 3];

        for (i=0; i<2; i++)
                while (x%p[i] == 0)
                        x/=p[i];

        return x;
}

function nextsprime(x)    // returns the next integer only made of small primes
{
        while (smallprimes(x)!=1)
                x++;

        return x;
}

var basefreq = 110, maxfreq = 7900, samplerate = 44100, pixpersec = 50;
var bpo = (canvasHeight-1) / (Math.log2(maxfreq) - Math.log2(basefreq));
var sbsize = nextsprime(canvasWidth * 2);	    // In Circular mode keep it to sbsize = Xsize * 2;
var Bc = Math.round(0.25 * sbsize);
var Mh = (sbsize + 1) >> 1;
var TRANSITION_BW_SYNT = 16.0; // defines the transition bandwidth for the low-pass filter on the envelopes during synthesis
var tbw = (1.0/TRANSITION_BW_SYNT) * (Mh-1), bwl = Math.ceil(tbw); // double transition bandwidth
var freq = [], filter = [];

maxfreq /= samplerate
basefreq /= samplerate;       // basefreq is now in fraction of the sampling rate instead of Hz
pixpersec /= samplerate;      // pixpersec is now in fraction of the sampling rate instead of Hz

for (var i=0;i<canvasHeight;i++)
{
	freq[i] = log_pos(i/(canvasHeight-1), basefreq, maxfreq);  //band's central freq
}

// generation of the frequency-domain filter
for (var i=1; i<Mh; i++)
	filter[i] = 1.0;

for (var i=0; i<bwl; i++)
{
	var x = i / tbw; // position in the antiderivate of the Blackman function of the sample we're at, between 0.0 and 1.0
	var coef = 0.42*x - (0.5/(2.0*Math.PI))*Math.sin(2.0*Math.PI*x) + (0.08/(4.0*Math.PI))*Math.sin(4.0*Math.PI*x); // antiderivative of the Blackman function
	coef *= 1.0/0.42;
	filter[i+1] = coef;
	filter[Mh-1-i] = coef;
}

var FFTW_ESTIMATE = (1 << 6);
var fftwModule = FFTWModule({});
var fftw_plan_r2r_1d = fftwModule.cwrap('fftwf_plan_r2r_1d', 'number', ['number', 'number', 'number', 'number', 'number']);
var fftw_execute = fftwModule.cwrap('fftwf_execute', 'void', ['number']);
var fftw_destroy_plan = fftwModule.cwrap('fftwf_destroy_plan', 'void', ['number']);

function fft_alloc(N)
{
	var ptr = fftwModule._malloc(N*4);
	var a = new Float32Array(fftwModule.HEAPU8.buffer, ptr, N);
	return [a, ptr];
}
var fft_free = fftwModule._free;

function fft(ptr, N, method) /* method : 0 = DFT, 1 = IDFT, 2 = DHT */
{
        var p = fftw_plan_r2r_1d(N, ptr, ptr, method, FFTW_ESTIMATE);
        fftw_execute(p);
        fftw_destroy_plan(p);
}

function synt_sine(d)
{
        /*
         d is the original image (spectrogram)
         s is the output sound
         sband is the band's envelope upsampled and shifted up in frequency
         sbsize is the length of sband
         sine is the random sine look-up table
         *samplecount is the output sound's length
         ib is the band iterator
         i is a general purpose iterator
         bands is the total count of bands
         Fc is the index of the band's centre in the frequency domain on the new signal
         Bc is the index of the band's centre in the frequency domain on sband (its imaginary match being sbsize-Bc)
         Mh is the length of the real or imaginary part of the envelope's FFT, DC element included and Nyquist element excluded
         Mn is the length of the real or imaginary part of the sound's FFT, DC element included and Nyquist element excluded
         freq is the band's central frequency
         rphase is the band's sine's random phase
        */

	var samplecount = Math.round(0.5*sbsize/pixpersec); // Do not change this value as it would stretch envelopes
	var Mn = (samplecount + 1) >> 1;

        var [s, s_ptr] = fft_alloc(samplecount);              // allocation of the sound signal
	var [sband, sband_ptr] = fft_alloc(sbsize);           // allocation of the shifted band
	var sine = [];
        s.fill(0);

        for (var ib=0; ib<canvasHeight; ib++)
        {
                sband.fill(0);    // reset sband

                //********Frequency shifting********

                var rphase = (Math.random() - 0.5) * 2 * Math.PI; // random phase between -pi and +pi

                for (var i=0; i<4; i++)                           // generating the random sine LUT
                        sine[i]=Math.cos(i*2.0*Math.PI*0.25 + rphase);

                for (var i=0; i<canvasWidth; i++)                 // envelope sampling rate * 2 and frequency shifting by 0.25
                {
                        if ((i & 1) == 0)
                        {
                                sband[i<<1] = d[canvasHeight-ib-1][i] * sine[0];
                                sband[(i<<1) + 1] = d[canvasHeight-ib-1][i] * sine[1];
                        }
                        else
                        {
                                sband[i<<1] = d[canvasHeight-ib-1][i] * sine[2];
                                sband[(i<<1) + 1] = d[canvasHeight-ib-1][i] * sine[3];
                        }
                }
                //--------Frequency shifting--------

                fft(sband_ptr, sbsize, 0);                        // FFT of the envelope
                var Fc = Math.round(freq[ib] * samplecount);      // band's centre index (envelope's DC element)

                //********Write FFT********

                for (var i=1; i<Mh; i++)
                {
                        if (Fc-Bc+i > 0 && Fc-Bc+i < Mn)     // if we're between frequencies 0 and 0.5 of the new signal and that we're not at Fc
                        {
                                s[i+Fc-Bc] += sband[i] * filter[i];                            // Real part
                                s[samplecount-(i+Fc-Bc)] += sband[sbsize-i] * filter[i];       // Imaginary part
                        }
                }
                //--------Write FFT--------
        }

        fft(s_ptr, samplecount, 1);                               // IFFT of the final sound
        samplecount = Math.round(canvasWidth/pixpersec);          // chopping tails by ignoring them

	// normalise the signal to the +/- 1.0 range

        var max=0;
	for (var ix=0; ix<samplecount; ix++)
		if (Math.abs(s[ix])>max)
			max=Math.abs(s[ix]);

        if (max!=0.0)
                max = 1.0/max;

	for (var ix=0; ix<samplecount; ix++)
		s[ix]*=max;

	var wavfile = new Float32Array(s.slice(0, samplecount));

	fft_free(s_ptr);
	fft_free(sband_ptr);
	return wavfile;
}

$(prepareCanvas);

</script>
